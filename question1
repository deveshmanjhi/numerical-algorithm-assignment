"""
import numpy as np

objective=[1,3]
constraint1=[10,5,4]
constraint2=[(1,2),(1,0),(0,1)]

class LPsolver():

    def solve(self,a,b,c):
        l_b=len(b)
        l_a=len(a)
        arr=np.array(c)
        arr=np.concatenate((arr,np.identity(len(b))),1)
        b=np.array(b)
        x=[0]*l_a

        arr=np.insert(arr,len(a)+l_b,b,1)
        B=np.array([0]*l_b)
        C=np.array(a+[0]*l_b)
        bx=range(l_a,l_a+l_b)
        while(1):
            maxpos=[]
            minpos=[]
            for i in range(l_a+l_b):
                maxpos.append(C[i]-np.dot(B,arr[:,i]))


            c=maxpos.index(max(maxpos))

            if maxpos[c]<=0:
                break
            for i in range(l_b):
                if arr[i,c]!=0:
                    minpos.append(arr[i,-1]/arr[i,c])
                else:
                    minpos.append(10000000000)
            q=filter(lambda x:x>0,minpos)
            if q==[]:
                return "unbounded function"
                break
            r=minpos.index(min(q))

            B[r]=C[c]
            bx[r]=c
            arr[r,:]=arr[r,:]/arr[r,c]
            for i in range(l_b):
                if(i!=r):
                    arr[i,:]=arr[i,:]-(arr[i,c]/arr[r,c])*arr[r,:]

        for i in range(len(bx)):
            if bx[i]<l_a:
                x[bx[i]]=arr[i,-1]
        x=map(int,x)

        x.append(sum([x[i]*a[i] for i in range(l_a)]))
        return x


lps=LPsolver()
solution=lps.solve(objective,constraint1,constraint2)
print solution
"""

class LPSolver:
    cff, z_max, z_min, x, point = [], [], [], [0,0,0,0], []    
    def solve(self,method_name,hex,consr,consl) : 
        if method_name == 'Simplex':
                           
            self.graph_plot(consr,consl)
           
            for i in consl:
                self.cff += [[j for j in i]]
            for i in range(len(consr)):
                self.cff[i] += [0 for j in range(len(consr))]
                self.cff[i][len(hex)+i] = 1
        
            ob_cof = hex + [0 for i in range(len(consr))]
       
            fin_cof = [0 for i in range(len(consr))]    
            self.point = [i+3 for i in range(len(consr))] 
            while True:
                
                for i in range(len(ob_cof)):
                    sum = 0
                    for j in range(len(consr)):
                        sum += self.cff[j][i]*fin_cof[j]
                    self.z_max += [ob_cof[i]-sum]          
            
                counter = 0
                for i in self.z_max:
                    if i <= 0:
                        counter += 1
                if counter == len(ob_cof):
                    break
                
                index_bottom = self.z_max.index(max(self.z_max)) 
                
                for i in range(len(consr)):
                    if self.cff[i][index_bottom] != 0:
                        self.z_min += [consr[i]*1.0/self.cff[i][index_bottom]]
                    elif consr[i] > 0:
                        self.z_min += ["Infinity"]
                    else:
                        self.z_min += ["-Infinity"] 
                counter = 0
           
                for i in self.z_min:
                    if i != "Infinity":
                        if i == "-Infinity":
                            counter += 1
                        elif i<=0:    
                            counter += 1
                if counter == len(consr):
                    return " Problem Is Unbounded "
              
                pos_val_collec = []
                for i in self.z_min:
                    if i!="Infinity" and i!="-Infinity":
                        if i>0:
                           pos_val_collec += [i] 
                
                index_right = pos_val_collec.index(min(pos_val_collec))+1              
             
                counter = 0
                for i in self.z_min:
                   if i!="Infinity" and i!="-Infinity":
                        if i > 0:
                            counter += 1
                   if counter == index_right:
                        index_right = self.z_min.index(i)
                        break 
          
                fin_cof[index_right] = ob_cof[index_bottom]            
                consr[index_right] = consr[index_right]*1.0/self.cff[index_right][index_bottom]
             
                self.point[index_right] = index_bottom+1
               
                pivot = self.cff[index_right][index_bottom]     
            
                for i in range(len(ob_cof)):
                    self.cff[index_right][i] = self.cff[index_right][i]/(pivot*1.0)    
             
                for i in range(len(consr)):
                    if i != index_right:
                        num = self.cff[i][index_bottom]
                        for j in range(len(ob_cof)):
                             self.cff[i][j] -= num*self.cff[index_right][j]
                        consr[i] -= num*consr[index_right]
             
                self.x[0] = self.x[2]
                self.x[1] = self.x[3]
                if 1 in self.point:
                    self.x[2] = consr[self.point.index(1)]
                if 2 in self.point:
                    self.x[3] = consr[self.point.index(2)]                   
                self.status_aft_e_iteration()
                print (self.cff, self.z_max, self.z_min, self.x, self.point, ob_cof,fin_cof)        
                self.z_max, self.z_min = [], []                             
        sum = 0
        for i in range(len(fin_cof)):
            sum += fin_cof[i]*consr[i]
        return sum     
  
    def graph_plot(self,rs_cnstrts,ls_cnstrts):
        import matplotlib.pyplot as plt
        plt.plot(0,0,'ko')
        plt.xlabel('x axis')
        plt.ylabel('y axis')
        for i in range(len(rs_cnstrts)):
            x = [0,rs_cnstrts[i]*1.0/ls_cnstrts[i][0]]
            y = [rs_cnstrts[i]*1.0/ls_cnstrts[i][1],0]
            plt.plot(x,y,linewidth=3.0)
            plt.show()
    def status_aft_e_iteration(self):
        import matplotlib.pyplot as plt
        x1, y1, x2, y2 = self.x[0], self.x[1], self.x[2], self.x[3]
        plt.plot(x2, y2,'ko')
        plt.annotate('', xy = ((x1+2*x2)/3.0,(y1+2*y2)/3.0), xytext = ((x2+2*x1)/3.0,(y2+2*y1)/3.0), 
        arrowprops = dict(facecolor = 'black',shrink = 0.03))
        plt.show()

